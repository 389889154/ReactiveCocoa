// This is auto-generated by gyb.

import Foundation
import ReactiveSwift
import enum Result.NoError
import UIKit

extension UIActivityIndicatorView {

	// isAnimating: Bool

	public static func <~ <Source: BindingSourceProtocol>(
		target: UIActivityIndicatorView,
		source: Source
	) -> Disposable? where Source.Value == Bool, Source.Error == NoError {
		return target.reactive.isAnimating <~ source
	}

}
extension NSLayoutConstraint {

	// constant: CGFloat

	public static func <~ <Source: BindingSourceProtocol>(
		target: NSLayoutConstraint,
		source: Source
	) -> Disposable? where Source.Value == CGFloat, Source.Error == NoError {
		return target.reactive.constant <~ source
	}

}
extension UISwitch {

	// isOn: Bool

	public static func <~ <Source: BindingSourceProtocol>(
		target: UISwitch,
		source: Source
	) -> Disposable? where Source.Value == Bool, Source.Error == NoError {
		return target.reactive.isOn <~ source
	}

}
extension UITextView {

	// text: String

	public static func <~ <Source: BindingSourceProtocol>(
		target: UITextView,
		source: Source
	) -> Disposable? where Source.Value == String, Source.Error == NoError {
		return target.reactive.text <~ source
	}

}
extension UIDatePicker {

	// date: Date

	public static func <~ <Source: BindingSourceProtocol>(
		target: UIDatePicker,
		source: Source
	) -> Disposable? where Source.Value == Date, Source.Error == NoError {
		return target.reactive.date <~ source
	}

}
extension UITextField {

	// text: String?

	public static func <~ <Source: BindingSourceProtocol>(
		target: UITextField,
		source: Source
	) -> Disposable? where Source.Value == String?, Source.Error == NoError {
		return target.reactive.text <~ source
	}


	// text: String

	public static func <~ <Source: BindingSourceProtocol>(
		target: UITextField,
		source: Source
	) -> Disposable? where Source.Value == String, Source.Error == NoError {
		return target.reactive.text <~ source
	}

}
extension UISegmentedControl {

	// selectedSegmentIndex: Int

	public static func <~ <Source: BindingSourceProtocol>(
		target: UISegmentedControl,
		source: Source
	) -> Disposable? where Source.Value == Int, Source.Error == NoError {
		return target.reactive.selectedSegmentIndex <~ source
	}

}
extension UIImageView {

	// image: UIImage

	public static func <~ <Source: BindingSourceProtocol>(
		target: UIImageView,
		source: Source
	) -> Disposable? where Source.Value == UIImage, Source.Error == NoError {
		return target.reactive.image <~ source
	}

}
extension UIProgressView {

	// progress: Float

	public static func <~ <Source: BindingSourceProtocol>(
		target: UIProgressView,
		source: Source
	) -> Disposable? where Source.Value == Float, Source.Error == NoError {
		return target.reactive.progress <~ source
	}

}
extension UILabel {

	// text: String?

	public static func <~ <Source: BindingSourceProtocol>(
		target: UILabel,
		source: Source
	) -> Disposable? where Source.Value == String?, Source.Error == NoError {
		return target.reactive.text <~ source
	}


	// text: String

	public static func <~ <Source: BindingSourceProtocol>(
		target: UILabel,
		source: Source
	) -> Disposable? where Source.Value == String, Source.Error == NoError {
		return target.reactive.text <~ source
	}


	// attributedText: NSAttributedString?

	public static func <~ <Source: BindingSourceProtocol>(
		target: UILabel,
		source: Source
	) -> Disposable? where Source.Value == NSAttributedString?, Source.Error == NoError {
		return target.reactive.attributedText <~ source
	}


	// attributedText: NSAttributedString

	public static func <~ <Source: BindingSourceProtocol>(
		target: UILabel,
		source: Source
	) -> Disposable? where Source.Value == NSAttributedString, Source.Error == NoError {
		return target.reactive.attributedText <~ source
	}

}


extension UIDatePicker: BindingSourceProtocol {
	public func observe(_ observer: Observer<Date, NoError>) -> Disposable? {
		return reactive.dates.observe(observer)
	}
}
extension UITextField: BindingSourceProtocol {
	public func observe(_ observer: Observer<String?, NoError>) -> Disposable? {
		return reactive.textValues.observe(observer)
	}
}
extension UISwitch: BindingSourceProtocol {
	public func observe(_ observer: Observer<Bool, NoError>) -> Disposable? {
		return reactive.isOnValues.observe(observer)
	}
}
extension UITextView: BindingSourceProtocol {
	public func observe(_ observer: Observer<String?, NoError>) -> Disposable? {
		return reactive.textValues.observe(observer)
	}
}
extension UISegmentedControl: BindingSourceProtocol {
	public func observe(_ observer: Observer<Int, NoError>) -> Disposable? {
		return reactive.selectedSegmentIndexes.observe(observer)
	}
}
